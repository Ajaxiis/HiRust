Алгоритм абстракции: 
Абстрактный блок ( часть программы) хранится в нескольких файлах: 
element.png - иконка элемента, element.toml - данные  элемента. 
 Содержание файла element.toml:
Название элемента - переменная для схемы.
Версия- номер версии элемента.
Иконка - соответствующая иконка для схемы. 
Категория - место иконки в соответствующем разделе графического интерфейса. 
Пакет- библиотека содержащая данный элемент из сайта crates.io для компилятора (прописывается в файле cargo.toml) компилируемого проекта. 
Методы - вектор перечисления точек методов. 
Свойства методов - вектор соответствующий методам (описание переменных)
Значения: вектор значений по умолчанию для методов.
Функции- вектор кодов команд соответствующих методов. 
Переменные: список переменных для элемента 
Свойства переменных: соответствующий вектор переменным с описанием 
Значения переменных : соответствующий вектор переменных со значением по умолчанию (если нужно) 
 

Как это выглядит на схеме: 
Элемент- это иконка ( квадрат или прямоугольник) на котором слева точки входа ( функции) справа точки выхода  потока данных или команд. Сверху - точки используемых переменных, снизу - значения переменных в элементе. 

Например: элемент if будет содержать точки : 
Слева :doif- точка запуска элемента , 
сверху :2 точки сравниваемых переменных , 
справа - 2 точки : ок- при выполнении условия и else если условие не выполняется. 

Работа программы: 
Линкер - это служебная функция, назначение которой перевести графическую абстракцию готовой схемы в служебный код для компилятора. 
Поскольку мы будем использовать внешний линкер cargo  то компиляция схемы в код будет состоять из трех этапов:
Линковка - преобразование графической схемы в код.
Кодировка - создание и сохранение конечного кода для компилятора.
Запуск компилятора cargo для построения бинарного выходного кода или библиотеки . 
Идея: продумать возможность загрузки скомпилированного на crates.io или  github.com
 
Работа линкера:
При соединении точек в схеме, линкер обращается к файлам соединяемых компонентов. При этом происходит "оптимизация" создание внутренних переменных и наполнение их ссылок на файлы используемых элементов схемы.
Очевидно, что не нужно каждый раз обращаться к одному и тому же файлу компонента если этот компонент используется множество раз.
Достаточно пропарсить файл единожды и сохранить для каждого последующего компонента значение отличающееся от предыдущих.
Таким образом создаётся типа дорожной карты для  парсера -кодогенератора.
Алгоритм работы: 
Парсим файл схемы на наличие элементов, создаём ссылки на файлы элементов в виде списка для парсинга. 
